#### Lab2 Key/Value Server

​	第二个 Lab 需要实现一个并发的键值对数据库服务器, 需要在不同客户端的请求之间保持串行一致性, 即服务器应该表现为如同客户端的请求按照某种特定的顺序到达. 可以采用多版本并发控制.

​	服务端需要维护两张表, 一张是数据表, 一张是客户端的同步信息表.

1. 数据表 `data`: `sync.Map` 类型, `key` 即为实际的客户传过来的键值, `value` 为如下的结构体的指针类型:

   ```go
   type Value struct {
     value string
     sync.RWMutex
   }
   ```

   从结构体上看, 数据表采用读写锁来保证数据读写的原子性. 因为 Go 没有类似 `fetch_add` 之类对新值进行操作后获取旧值的原子操作, 否则可以直接使用原子变量.

2. 同步信息表 `clientsSync`: 用于存储客户端的同步信息, 之后会有更多介绍.

##### 网络不稳定问题

​	客户端在发送 RPC 请求时, 通常会在发送后等待一段时间, 若无回复, 则再次发送, 直到收到服务端的回复. 在网络不稳定的情况下, 可能导致多个相同的RPC发送到服务端. 如果是写操作的RPC, 将会导致非一致性的情况出现. 

​	为了解决这个问题, 我们使用 RPC 序号匹配的机制:

1. 每个 client 在初始化携带一个唯一的id, 发送 RPC 写请求到服务器的时候需要携带该 ID. 在第一次发送的时候, 服务器将会注册该 client ID. 同时双方约定起始的 RPC 写操作的 ID 为1, 客户端每一次发送一个写操作时都需要将该 RPC ID 加一, 服务端每次受理一次也将 RPC ID 加一. 

   在理想的网络情况下, 双方的 RPC ID 应该是同步的. 

2. 但是在不稳定的网络情况下, RPC 请求和回复都有可能丢失, 不管哪个丢失, 最终都会导致客户端的「超时重传」. 这种情况并不会影响服务端, 因为请求根本没有到达服务端.

   但在一些情况下, RPC 并没有丢失, 只是因为网络阻塞导致RPC到达服务端的时延很大, 但最终也会触发客户端的超时重传, 最终可能有多个相同的 RPC 写请求到达服务端.

3. 首先解决「多个相同写请求」的问题, 在使用 RPC ID 机制的情况下, 我们约定「服务端只有在 RPC ID 匹配的条件下进行写操作」. 这样即便有多个相同 RPC 请求相继到达服务端, 它们肯定携带相同的 客户端的 RPC ID, 而服务端在处理第一个请求之后 RPC ID 已经加一, 之后的所有请求必定无法匹配, 从而保证「同一个写请求只会被执行一遍」.

   尽管不会执行写请求, 但是服务端也会响应之后到达的请求, 即直接将相应的结果返回即可, 对于 Append RPC, 对于每个 client 需要在表中保留一个字段保留其最后一次已完成的 Append 操作的返回值, 用于响应之后到达的所有 duplicate Append RPC.

   总而言之, 服务端在收到客户端请求之后: 首先比较双方的 RPC ID, 若相等, 则继续执行请求; 若客户端落后, 则直接响应结果, 并将自己的 RPC ID 一起返回给客户端, 告诉客户端下次使用该 RPC ID 继续发送请求.
