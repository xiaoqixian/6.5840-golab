### Lab3 Raft

#### A. Leader Election

​	节点投票机制: 

- 若候选者的任期小于自己, 则拒绝投票. 并回送自己当前leader的term和 leader id.

候选者期望得到的选票回复为以下几种:

1. 给票
2. 拒绝给票, 因为已经投票给其它候选者, 则候选者需要检查其它候选者的term, 如果大于自己的应该立刻中止选举.
3. 拒绝给票, 因为有一个term不小于候选者term的leader存在, 则候选者应该立刻中止选票. 

​	

##### 	群雄割据

- 同一时刻, 集群可能存在多个候选者“割据”的状态, 并且它们的 term id 可能相同, 在这种情况下可能无法成功选举出一个leader. 

  基于这种情况, 候选者的选举实际是一个循环, 当循环结束而候选者的状态仍然是 `POLLING` 时, 说明此次循环没有获胜者, 随机沉睡一段时间后继续选举, 重新选举需要清空所有选票, 并将自己的候选任期加一.

  直到以下三种情况之一发生:

  1. 在选举中被击败, 收到 term 大于自己的 候选者发送的 RequestVote
  2. 赢得选举
  3. 选举遭到打断, 例如收到不小于自己候选任期的服务器的 AppendEntries RPC, 则说明集群内已经选举产生一个 leader, 只是自己还没有收到消息. 则立刻停止选举, 回退为一个 跟随者.

##### 并发与锁

​	每个节点应该表现为一个被动触发的有限状态机, 主线程只运行一个死循环保证程序不会退出. 其它操作由定时器和 RPC 调用触发完成. 而节点的所有操作是基于当前的身份来完成的, 这引出一个问题: 如何保证节点被并发触发时的一致性. 

1. 节点的身份由一个读写锁来保护, 为了保证节点的可用性, 强调锁的快速释放.
2. follower 的投票只能投票给一个节点, 因此需要一个锁来保护. 
3. 节点的所有 entries 需要通过锁来保护.

